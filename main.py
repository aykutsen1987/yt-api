from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import yt_dlp
import os
import logging
from pathlib import Path

# Logging ayarları
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# FastAPI uygulaması
app = FastAPI(title="YouTube MP3 API", version="1.0.0")

# Downloads klasörünü oluştur
DOWNLOADS_DIR = Path("downloads")
DOWNLOADS_DIR.mkdir(exist_ok=True)

# Cookies dosyası
COOKIES_FILE = Path("cookies.txt")

# Statik dosya servisi
app.mount("/downloads", StaticFiles(directory="downloads"), name="downloads")

# Request modelleri
class CookieRequest(BaseModel):
    cookies: str

class MP3Request(BaseModel):
    url: str

# yt-dlp ayarları
def get_ydl_opts():
    return {
        "format": "bestaudio/best",
        "extractaudio": True,
        "audioformat": "mp3",
        "outtmpl": "downloads/%(id)s.%(ext)s",
        "noplaylist": True,
        "nocheckcertificate": True,
        "cookies": str(COOKIES_FILE) if COOKIES_FILE.exists() else None,
        "extractor_args": {
            "youtube": {
                "player_client": ["default"]
            }
        },
        "postprocessors": [{
            "key": "FFmpegExtractAudio",
            "preferredcodec": "mp3",
            "preferredquality": "192",
        }],
    }

@app.get("/")
async def root():
    return {
        "message": "YouTube MP3 API",
        "version": "1.0.0",
        "endpoints": {
            "health": "/health",
            "update_cookies": "/update_cookies (POST)",
            "mp3": "/mp3 (POST)"
        }
    }

@app.get("/health")
async def health_check():
    """Sunucu sağlık kontrolü"""
    cookie_status = "loaded" if COOKIES_FILE.exists() else "not_set"
    return {
        "status": "healthy",
        "cookies": cookie_status,
        "downloads_dir": str(DOWNLOADS_DIR.absolute())
    }

@app.post("/update_cookies")
async def update_cookies(request: CookieRequest):
    """
    Android uygulamasından gelen cookie'leri kaydet
    
    Body:
    {
        "cookies": "HSID=...; SID=...; SAPISID=..."
    }
    """
    try:
        # Cookie'yi Netscape formatında kaydet
        with open(COOKIES_FILE, "w", encoding="utf-8") as f:
            # Netscape HTTP Cookie File header
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# This file was generated by YouTube MP3 API\n\n")
            
            # Cookie'leri parse et ve kaydet
            cookies = request.cookies.strip()
            if not cookies:
                raise ValueError("Cookie verisi boş olamaz")
            
            # Basit cookie formatı (key=value; key2=value2)
            # YouTube için genellikle bu format yeterli
            for cookie in cookies.split(";"):
                cookie = cookie.strip()
                if "=" in cookie:
                    key, value = cookie.split("=", 1)
                    # Netscape format: domain, flag, path, secure, expiration, name, value
                    f.write(f".youtube.com\tTRUE\t/\tTRUE\t0\t{key.strip()}\t{value.strip()}\n")
        
        logger.info("Cookies başarıyla güncellendi")
        return {
            "status": "success",
            "message": "Cookie'ler başarıyla kaydedildi",
            "file": str(COOKIES_FILE)
        }
    
    except Exception as e:
        logger.error(f"Cookie kaydetme hatası: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Cookie kaydetme hatası: {str(e)}")

@app.post("/mp3")
async def download_mp3(request: MP3Request):
    """
    YouTube videosunu MP3 olarak indir ve URL döndür
    
    Body:
    {
        "url": "https://www.youtube.com/watch?v=XXXXX"
    }
    """
    try:
        url = request.url.strip()
        
        if not url:
            raise HTTPException(status_code=400, detail="URL boş olamaz")
        
        if "youtube.com" not in url and "youtu.be" not in url:
            raise HTTPException(status_code=400, detail="Geçerli bir YouTube URL'si giriniz")
        
        logger.info(f"İndirme başlatıldı: {url}")
        
        # Video bilgilerini al
        ydl_opts = get_ydl_opts()
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            # Video bilgilerini çek
            info = ydl.extract_info(url, download=False)
            video_id = info.get("id")
            title = info.get("title", "Unknown")
            duration = info.get("duration", 0)
            
            # MP3 dosya yolu
            mp3_file = DOWNLOADS_DIR / f"{video_id}.mp3"
            
            # Dosya zaten varsa tekrar indirme
            if mp3_file.exists():
                logger.info(f"Dosya zaten mevcut: {mp3_file}")
                file_size = mp3_file.stat().st_size
                
                # Sunucu base URL'ini oluştur (Render için)
                base_url = os.getenv("RENDER_EXTERNAL_URL", "http://localhost:8000")
                audio_url = f"{base_url}/downloads/{video_id}.mp3"
                
                return {
                    "status": "ok",
                    "cached": True,
                    "title": title,
                    "duration": duration,
                    "file_size": file_size,
                    "audio_url": audio_url
                }
            
            # Video indir
            logger.info("Dosya indiriliyor...")
            ydl.download([url])
            
            # İndirilen dosyayı kontrol et
            if not mp3_file.exists():
                raise FileNotFoundError(f"MP3 dosyası oluşturulamadı: {mp3_file}")
            
            file_size = mp3_file.stat().st_size
            logger.info(f"İndirme tamamlandı: {mp3_file} ({file_size} bytes)")
            
            # Sunucu base URL'ini oluştur
            base_url = os.getenv("RENDER_EXTERNAL_URL", "http://localhost:8000")
            audio_url = f"{base_url}/downloads/{video_id}.mp3"
            
            return {
                "status": "ok",
                "cached": False,
                "title": title,
                "duration": duration,
                "file_size": file_size,
                "audio_url": audio_url
            }
    
    except yt_dlp.utils.DownloadError as e:
        error_msg = str(e)
        logger.error(f"yt-dlp hatası: {error_msg}")
        
        if "Sign in to confirm you're not a bot" in error_msg or "This helps protect our community" in error_msg:
            raise HTTPException(
                status_code=403, 
                detail="YouTube bot koruması aktif. Lütfen cookie'leri güncelleyin (/update_cookies)"
            )
        elif "Video unavailable" in error_msg:
            raise HTTPException(status_code=404, detail="Video bulunamadı veya kullanılamıyor")
        else:
            raise HTTPException(status_code=500, detail=f"İndirme hatası: {error_msg}")
    
    except FileNotFoundError as e:
        logger.error(f"Dosya hatası: {str(e)}")
        raise HTTPException(status_code=500, detail="MP3 dönüştürme başarısız. FFmpeg kurulu mu?")
    
    except Exception as e:
        logger.error(f"Beklenmeyen hata: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Sunucu hatası: {str(e)}")

@app.get("/list")
async def list_files():
    """İndirilen MP3 dosyalarını listele"""
    try:
        files = []
        for file in DOWNLOADS_DIR.glob("*.mp3"):
            files.append({
                "filename": file.name,
                "size": file.stat().st_size,
                "url": f"/downloads/{file.name}"
            })
        
        return {
            "status": "ok",
            "count": len(files),
            "files": files
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
